#separator:tab
#html:true
#notetype:Basic
#deck:neetcode 150
#tags column:3
<b>Contains Duplicate</b></br>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.	<b>OPTIMIZED</b></br>Add chars to HashSet while iterating. If already present, return True</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Iterate through array, for each element, check if it is present in the rest of the array, return True if found, otherwise False</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Arrays&Hashing
<b>Valid Anagram</b></br>Given two strings s and t, return true if t is an anagram of s, and false otherwise.	<b>OPTIMIZED</b></br>If lengths of s and t are not same, return False. Use counter(HashMap) to track character frequencies by incrementing for characters in s and decrementing for those in t. if any counts are not zero, return False; otherwise, return True</br><b>COMPLEXITY</b></br>Time: O(n+m); Space: O(1)</br><b>BRUTE FORCE</b></br>Return False is unequal lengths. Sort both strings, compare each character, return False on mismatch, else True</br><b>COMPLEXITY</b></br>Time: O(nlogn + mlogm); Space: O(1)	Arrays&Hashing
<b>Two Sum</b></br>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target .You may assume that each input would have exactly one solution , and you may not use the same element twice.You can return the answer in any order.	<b>OPTIMIZED</b></br>Store difference between the target and each number (target - num) in a HashMap with the current index as value. If the required value is already in the HashMap, return a list of indices of the pair that is found</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>For each element(i), iterate through rest of the array(j), searching for a sum of target. Return indices(i, j) if found, else []</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Arrays&Hashing
<b>Group Anagrams</b></br>Given an array of strings strs, group the anagrams together. You can return the answer in any order.	<b>OPTIMIZED</b></br>Use a HashMap with char_count[26] tuples as keys, appending words that match the count. Finally, return the HashMap's values.</br><b>COMPLEXITY</b></br>Time: O(m*n); Space: O(m)</br><b>BRUTE FORCE</b></br>Create a defaultdict(list) for res. Iterate through strs, sort each str using it as the dict key, append str to the value list. return values</br><b>COMPLEXITY</b></br>Time: O(m * nlogn); Space: O(m*n)	Arrays&Hashing
<b>Top K Frequent Elements</b></br>Given an integer array nums and an integer k, return the k most frequent elements . You may return the answer in any order . 	<b>OPTIMIZED</b></br>First create a num_count HashMap, from which create an ordered map of counts with corresponding numbers (List[List]). Iterate in reverse, appending numbers to the result, and return when enough values are collected</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Create a freq map. Maintain a maxHeap(based on freq) of len k, while appending pairs(frequency, char). Iterate k times popping from heap and pushing char to res</br><b>COMPLEXITY</b></br>Time: O(n logk); Space: O(n+k)	Arrays&Hashing
<b>String Encode and Decode</b></br>Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.Please implement encode and decode	 <b>OPTIMIZED</b></br>Use the format <len#word>; for encoding. To decode, use two pointers and two while loops to read the length, then append the word slice to the result</br><b>COMPLEXITY</b></br>Time: O(m); Space: O(1), where m- sum of lengths of all strings</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br> 	Arrays&Hashing
<b>Product of Array Except Self</b></br>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation. 	<b>OPTIMIZED</b></br>Initialize prod = 1. Loop L-R. First update ans array, ans[i] *= prod. Then update prod, prod *= nums[i], to use in the next iteration. Repeat the process R-L</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate through nums in nested loops, if i ==j continue otherwise multiply with running sum, add to res[i] at end of j loop</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Arrays&Hashing
<b>Valid Sudoku</b></br>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules :<ol><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ol> Note: <ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul> 	<b>OPTIMIZED</b></br>Create 3 HashMaps of hash sets for- rows, cols & squares. For squares, use tuple (i // 3, j // 3) as the key. If duplicate in any of the 3 hashsets return False, otherwise add to all 3 maps. Return True at the end</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(n^2)</br><b>BRUTE FORCE</b></br>Similar logic to optimized, but execute across 3 loops</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(n^2)	Arrays&Hashing
<b>Longest Consecutive Sequence</b></br>Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. 	<b>OPTIMIZED</b></br>Convert nums to a set. For each number, check if num-1 is present (indicating the start of a sequence). If yes, iteratively check until there are no more num+1 elements in the set. Then update the longest sequence length</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Convert nums to hashset. For each num, check for the longest, streak by adding 1 and checking for existence in hashset.</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(n)	Arrays&Hashing
<b>Valid Palindrome</b></br>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.<br>Given a string s, return true if it is a palindrome , or false otherwise . 	<b>OPTIMIZED</b></br>Iterate with L & R pointers, skip invalid characters with ASCII range checks, compare in lowercase, finally return True if no mismatches found</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate through string and create a new string of valid characters. Compare using 2 pointers</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	Two-Pointers
<b>Two Sum II - Input Array Is Sorted</b></br>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.<br>Return the indices of the two numbers, index1 and index2 , added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution . You may not use the same element twice.Your solution must use only constant extra space. 	<b>OPTIMIZED</b></br>Iterate with L & R pointers, adjust pointers based on cur_sum relative to target, and return indices if they match</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Nested loops, for each i we start j from i + 1, and return when we find a match</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Two-Pointers
<b>3Sum</b></br>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.<br>Notice that the solution set must not contain duplicate triplets. 	<b>OPTIMIZED</b></br>Sort the array and iterate through nums, skipping duplicates. For each nums[i], set target = -nums[i] and iterate using L & R pointers to find pairs that sum to the target. Add indices on a match, and skip duplicates for L followed by R pointers</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)</br><b>BRUTE FORCE</b></br>Use 3 loops, i = 0, j = i + 1 and k = j + 1. Find number[i] + number[j] + number[k] == target</br><b>COMPLEXITY</b></br>Time: O(n^3); Space: O(1)	Two-Pointers
<b>Container With Most Water</b></br>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).<br>Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store . Notice that you may not slant the container. 	<b>OPTIMIZED</b></br>Iterate with L & R pointers, calculate the current area and update max_area if larger, then move pointer with the lower height</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Use nested for loops, the outer loop for l and inner for right. Calculate the max_area for each pointer widths. Return max_area at the end</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Two-Pointers
<b>Trapping Rain Water</b></br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.<br> 	<b>OPTIMIZED</b></br>Create left_max and right_max arrays(based on height[i-1]). Iterate len(height), calculating running sum of trapped_water(min(left_max, right_max) - height). Return trapped_water</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n) or O(1)</br><b>BRUTE FORCE</b></br>For each height, calculate left_max from index 0 and right_max using index len(height)-1. Compute running total for trapped_water, using same formula as optimized</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Two-Pointers
<b>Best Time to Buy and Sell Stock</b></br>You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 	<b>OPTIMIZED</b></br>Set buy to prices[0], iterate through prices calculating profit, and update if larger</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Use nested loops, 1 to track buy and other to track sell(starting from i+1). Calculate profit and maintain a running max. Return max_profit at the end.</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Sliding-Window
<b>Longest Substring Without Repeating Characters</b></br>Given a string s, find the length of the longest substring without repeating characters. 	<b>OPTIMIZED</b></br>Initialize L pointer to 0. Iterate over s, adding characters to a charSet. If duplicate is found, remove characters from left until duplicate is gone. Continuously update longest substring and return it at end</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(m), m is total number of unique characters in the string</br><b>BRUTE FORCE</b></br>Use a hashset to track duplicate characters. Use nested loops. In the outer loop, iterate through the string initializing an empty hashset on each iteration. In the inner loop, initialize an empty hashset and add characters until a duplicate is found.Break the inner loop when a duplicate appears and update max_length accordingly.</br><b>COMPLEXITY</b></br>Time: O(n*m); Space: O(m), m is total number of unique characters in the string	Sliding-Window
<b>Longest Repeating Character Replacement</b></br>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.<br>Return the length of the longest substring containing the same letter you can get after performing the above operations . 	<b>OPTIMIZED</b></br>Set L = 0 and iterate R through s, tracking the max frequency of any character by comparing against the current character count. Adjust L & char frequencies in window while the count of other characters exceeds k using maxf. Continuously update longest substring with repetitions and return it at end</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Sliding-Window
<b>Permutation in String</b></br>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.<br>In other words, return true if one of s1's permutations is the substring of s2.<br>	 <b>OPTIMIZED</b></br>Calculate char_count of s1. For each char in s2, if it exists in s1: create char_count of s2, with len(s1). If char_count's are same return True. Otherwise return False finally</br><b>COMPLEXITY</b></br>Time: O(n*m); Space: O(m), m is number of characters in s1</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Sliding-Window
<b>Minimum Window Substring</b></br>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t ( including duplicates ) is included in the window . If there is no such substring, return the empty string .The testcases will be generated such that the answer is unique . 	<b>OPTIMIZED</b></br>Use 2 variables called have & need & 2 HashMaps to track char counts in s and t, and initialize have to 0. Loop through s, updating window counts and incrementing have when (window[c] == count_t[c]). Loop while (have == len(count_t)), if current window is smaller than ans_len, update res and ans_len. Slide l right, adjusting window[s[l]] & have if window count goes below count_t. Return res</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(m), where m is total number of unique chars in t</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Sliding-Window
<b>Sliding Window Maximum</b></br>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.<br>Return the max sliding window . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Sliding-Window
<b>Valid Parentheses</b></br>Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.<br>An input string is valid if:<ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol> 	<b>OPTIMIZED</b></br>Use a HashMap {')': '('}. Iterate through the string: append open brackets to stack. For closing brackets, return False if the stack is empty or there's a mismatch with stack.pop(). At the end, return whether the stack is empty</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Replace '()', '{}', '[]' with '', replace is O(n), in case of nested brackets O(n^2)</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(n)	Stack
<b>Min Stack</b></br>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br>Implement the MinStack class:<ul><li>MinStack() initializes the stack object.</li><li>void push(int val) pushes the element val onto the stack.</li><li>void pop() removes the element on the top of the stack.</li><li>int top() gets the top element of the stack.</li><li>int getMin() retrieves the minimum element in the stack.</li></ul>You must implement a solution with O(1) time complexity for each function. 	<b>OPTIMIZED</b></br>Use 2 stacks: one for values and one to keep track of the minimum value so far (min_stack). During each insert, push the current minimum onto min_stack(push paid onto stack for O(n) space)</br><b>COMPLEXITY</b></br>Time: O(1); Space: O(n)</br><b>BRUTE FORCE</b></br>getMin(), searches stack each invocation</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	Stack
<b>Evaluate Reverse Polish Notation</b></br>You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.<br>Evaluate the expression. Return an integer that represents the value of the expression . Note that:<ul><li>The valid operators are '+', '-', '*', and '/'.</li><li>Each operand may be an integer or another expression.</li><li>The division between two integers always truncates toward zero .</li><li>There will not be any division by zero.</li><li>The input represents a valid arithmetic expression in a reverse polish notation.</li><li>The answer and all the intermediate calculations can be represented in a 32-bit integer.</li></ul> 	<b>OPTIMIZED</b></br>Use a stack to store operands. When an operator is encountered, pop the last two operands, perform the operation in the correct order, and push the result back onto the stack. At the end, return the last value in the stack</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Scan string using while len(s), For each operator- replace with result. and start scanning from beginning again</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(n)	Stack
<b>Generate Parentheses</b></br>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses .<br>	<b>OPTIMIZED</b></br>Use stack to store braces while generating valid combinations. Define dfs to recursively explore paths, skipping invalid paths based on counts of open & close brackets. Append stack content to the results when both counts equal n. If (o_cnt < n), add opening bracket, call dfs, then backtrack. If (c_cnt < o_cnt), add closing bracket, call dfs, then backtrack again. Return ans finally</br><b>COMPLEXITY</b></br>Time: O((4^n)/(n^1/2)); Space: O(n)</br><b>BRUTE FORCE</b></br>Create a func isValid(), generate all combinations using dfs. When length of string is same as n*2 and valid add to result.</br><b>COMPLEXITY</b></br>Time: O(2^2n * n); Space: O(2^2n * n)	Stack
<b>Daily Temperatures</b></br>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature . If there is no future day for which this is possible, keep answer[i] == 0 instead.<br>	<b>OPTIMIZED</b></br>Initialize ans array with 0's. Iterate through temperatures, while using a monotonically decreasing stack to store element index. While (temperature[i] > temperature[stack[top]]), pop from stack and update ans[stack_index] with difference between indices</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Iterate through temps, for each element, iterate through rest of temp to find diff in indexes. Append diff or 0 to res. Finally return res</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Stack
<b>Car Fleet</b></br>There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.<br>You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.Return the number of car fleets that will arrive at the destination. 	<b>OPTIMIZED</b></br>Sort (position, speed) pairs by position in ascending order. Iterate through pairs in reverse. For each car, calculate time to reach target; if this time <= the time at top of the stack, it joins the same fleet. Otherwise, add it to the stack. Finally, return the stack’s length as number of fleets</br><b>COMPLEXITY</b></br>Time: O(nlogn); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Stack
<b>Largest Rectangle in Histogram</b></br>Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram .<br>	<b>OPTIMIZED</b></br>Maintain a monotonically increasing stack (start, height). Iterate through heights, when a smaller element is found, pop all taller elements from the stack, processing their contribution to max_area and mark the start index of the current element as the last popped pushing current element onto the stack. Run an additional loop for remaining elements in the stack, calculating their heights wrt len(heights), updating max_area. Finally return max_area</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br>Iterate through heights, using expands from center, calculate right_most and left_most, followed by area. Update the running max_area.</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Stack
<b>Binary Search</b></br>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. 	<b>OPTIMIZED</b></br>Use 3 pointers: l, r & mid. Compare the mid value with the target and either move the window left/right or return the index if found</br><b>COMPLEXITY</b></br>Time: O(log n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate through array checking each if element matches target</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)	BinarySearch
<b>Search a 2D Matrix</b></br>You are given an m x n integer matrix matrix with the following two properties: <ul><li>Each row is sorted in non-decreasing order.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul>Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity. 	<b>OPTIMIZED</b></br>Use binary search to find row, where the target may lie based on row boundaries. If the target isn’t within any of the row ranges, return False. Otherwise, set the row to the last calculated midpoint and perform a binary search within that row for the target</br><b>COMPLEXITY</b></br>Time: O(log (m*n)); Space: O(1)</br><b>BRUTE FORCE</b>Iterate through rows using an outer loop, iterate through cols using inner loop. Compare each [r][c] with the target value.</br></br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	BinarySearch
<b>Koko Eating Bananas</b></br>Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. 	<b>OPTIMIZED</b></br>Use binary search between 1 and max(piles) to find the minimum eating speed. If a solution meets the hours constraint ℎ, try smaller speeds to minimize further. Return the last speed that satisfies the condition</br><b>COMPLEXITY</b></br>Time: O(n * log m); Space: O(1)</br><b>BRUTE FORCE</b></br>For each value in the range (1..largest), try to check if bananas can be eaten by the time</br><b>COMPLEXITY</b></br>Time: O(m*n); Space: O(1)	BinarySearch
<b>Find Minimum in Rotated Sorted Array</b></br>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:<ul><li>[4,5,6,7,0,1,2] if it was rotated 4 times.</li><li>[0,1,2,4,5,6,7] if it was rotated 7 times.</li></ul>Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. 	<b>OPTIMIZED</b></br>Initialize l and r to the start and end. Update ans, as min(ans, nums[mid]). If nums[mid] > nums[r], move window right; otherwise, move window left. Return min(nums[l], ans)</br><b>COMPLEXITY</b></br>Time: O(log n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate through each element, maintaining a running min. Return the min at the end of the loop.</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)	BinarySearch
<b>Search in Rotated Sorted Array</b></br>There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. 	<b>OPTIMIZED</b></br>Use 3 pointers l, r, mid. mid will be apart of either left sorted or right sorted portions. If target is in range of sorted portion then search it, otherwise search other half</br><b>COMPLEXITY</b></br>Time: O(log n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate through each element, comparing to target. Return if target was found or -1 if not at the end.</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)	BinarySearch
<b>Time Based Key-Value Store</b></br>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp. Implement the TimeMap class:<ul><li>TimeMap() Initializes the object of the data structure</li><li>void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.</li><li>String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns "".</li></ul>. 	<b>OPTIMIZED</b></br>Use a HashMap to store each key's list of [value, timestamp] pairs. For set, append the pair; for get, use binary search to find the most recent value with a timestamp ≤ the query using the concept of a running result that contains the most recent value found so far. Return it at the end</br><b>COMPLEXITY</b></br>Time: O(log n); Space: O(n)</br><b>BRUTE FORCE</b></br>Similar to optimized. but perform normal search in get</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	BinarySearch
<b>Median of Two Sorted Arrays</b></br>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	BinarySearch
<b>Reverse Linked List</b></br>Given the head of a singly linked list, reverse the list, and return the reversed list. 	<b>OPTIMIZED</b></br>Initialize prev, cur = None, head. Iterate through the list, updating prev and cur. At the end, return prev as the new head</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Recursion</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	LinkedList
<b>Merge Two Sorted Lists</b></br>You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 	<b>OPTIMIZED</b></br>Create an empty node cur with a pointer res. Iterate while both list1 and list2 are not None, adding the node with the lower value to cur. Then if either list is None, append the other list. Finally, return res.next</br><b>COMPLEXITY</b></br>Time: O(m+n); Space: O(1)</br><b>BRUTE FORCE</b></br>Recursive</br><b>COMPLEXITY</b></br>Time: O(m+n); Space: O(m+n)	LinkedList
<b>Linked List Cycle</b></br>Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 	<b>OPTIMIZED</b></br>Initialize f & s pointers to head. Iterate while f and f.next exist, moving f by 2 and s by 1. If they are equal, return True; otherwise, return False</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Reorder List</b></br>You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list's nodes. Only nodes themselves may be changed. 	<b>OPTIMIZED</b></br>Move the s pointer to the center of the list while ensuring f.next exists. Set s.next as the start of the second half, then set s.next to None to end the first half. Reverse the second list, then use 2 temp variables to merge both halves</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate to save nodes to a list, then apply merging logic.</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	LinkedList
<b>Remove Nth Node From End of List</b></br>Given the head of a linked list, remove the nth node from the end of the list and return its head. 	<b>OPTIMIZED</b></br>Create a dummy node pointing to head and assign it to l. Assign r to head and move r forward n times. Then, move both pointers until r reaches the end. Set l.next.next to l.next and return dummy.next</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Iterate to add nodes to a list. Using length of the list do index math to determine node to delete. Traverse and delete node</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)	LinkedList
<b>Copy List with Random Pointer</b></br>A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list. 	<b>OPTIMIZED</b></br>First, create a map to store the deep copies of each node. Traverse the original linked list, creating deep copies of all nodes. Then, traverse it again to set the next and random pointers for the copied nodes using the map. Finally, return the deep copy of the head node from the map</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Add Two Numbers</b></br>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space 	<b>OPTIMIZED</b></br>Traverse both input lists using a dummy node and maintain a carry. For each node, sum values and carry, add the remainder to the result list. Continue until both lists are exhausted, handling any leftover carry by adding an extra node. Return dummy.next as the final result</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Find the Duplicate Number</b></br>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and using only constant extra space. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>LRU Cache</b></br>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache .Implement the LRUCache class:<ul><li>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li><li>int get(int key) Return the value of the key if the key exists, otherwise return -1.</li><li>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</li></ul>The functions get and put must each run in O(1) average time complexity. 	<b>OPTIMIZED</b></br>Utilize a HashMap for quick value access and a doubly linked list (DLL) to track the order of usage. The DLL has two dummy nodes marking the LRU (left) and MRU (right). For put operations, the DLL functions like a queue, while get operations involve moving nodes to the MRU side, introducing extra complexity</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Merge k Sorted Lists</b></br>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. 	<b>OPTIMIZED</b></br>Create mergeLists() to merge two lists. While len(lists) > 1, run an inner loop to merge two lists at a time, append the result to mergedLists, and assign mergedLists to lists. Finally, return lists[0]</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Reverse Nodes in k-Group</b></br>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list .k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list's nodes, only nodes themselves may be changed. 	<b>OPTIMIZED</b></br>Use slow (s) and fast (f) pointers to traverse the list with an index counter i. When i is a multiple of k, disconnect f and move it forward. Reverse the sublist from s to f and connect it to the previous tail. Update prev_tail and start the next group from s. After traversal, connect any remaining nodes and return the modified list starting from dummy.next</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	LinkedList
<b>Invert Binary Tree</b></br>Given the root of a binary tree, invert the tree, and return its root . 	<b>OPTIMIZED</b></br>Traverse via dfs(). If node exists, replace left and right. Call dfs(left), then dfs(right)<b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Maximum Depth of Binary Tree</b></br>Given the root of a binary tree, return its maximum depth .A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 	<b>OPTIMIZED</b></br>Use recursive DFS with a leaf case returning 0. At each step, return 1 + the max height of the left and right subtrees</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Diameter of Binary Tree</b></br>Given the root of a binary tree, return the length of the diameter of the tree .The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.The length of a path between two nodes is represented by the number of edges between them. 	<b>OPTIMIZED</b></br>Use a maxHeight function, while before returning the height, maintain the calculate the diameter (l_height+r_height) and update max_diameter. Finally return max_diameter</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Balanced Binary Tree</b></br>Given a binary tree, determine if it is height-balanced 	<b>OPTIMIZED</b></br>Perform post order dfs, return -1 if subtree is not balanced.</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Same Tree</b></br>Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. 	<b>OPTIMIZED</b></br>For base cases, return True if both nodes are None. If either is None or values don’t match, return False. In the recursive case, return fn(left) and fn(right)</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Subtree of Another Tree</b></br>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself. 	<b>OPTIMIZED</b></br>Create a separate fn isSameTree() and perform BFS on the root. At each node, if isSameTree(node, subTree) return True. Finally if no same trees were found, return False</br><b>COMPLEXITY</b></br>Time: O(m*n); Space: O(m+n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Lowest Common Ancestor of a Binary Search Tree</b></br>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).” 	<b>OPTIMIZED</b></br>While True: if root.val > p and q, move left. If root.val < p and q, move right. Otherwise, if root lies between p and q or equals p or q, return root</br><b>COMPLEXITY</b></br>Time: O(h); Space: O(h), Where h is the height of the tree.</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Binary Tree Level Order Traversal</b></br>Given the root of a binary tree, return the level order traversal of its nodes' values . (i.e., from left to right, level by level).<br>	<b>OPTIMIZED</b></br>Add root to a Q. While the Q is not empty, initialize a level array. Run an inner loop for len(Q), adding node.val to level and left & right children back to the Q. If level is not empty, add it to res. Finally, return res</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Binary Tree Right Side View</b></br>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Count Good Nodes in Binary Tree</b></br>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.Return the number of good nodes in the binary tree. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Validate Binary Search Tree</b></br>Given the root of a binary tree, determine if it is a valid binary search tree (BST) .A valid BST is defined as follows:<ul><li>The left subtree of a node contains only nodes with keys less than the node's key.</li><li>The right subtree of a node contains only nodes with keys greater than the node's key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul> 	<b>OPTIMIZED</b></br>Define valid() with node, left, and right values. If node is None, return True. If node.val is not between left and right, return False. Recursively return valid(node.left, left, node.val) and valid(node.right, node.val, right)</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Kth Smallest Element in a BST</b></br>Given the root of a binary search tree, and an integer k, return the kth smallest value ( 1-indexed ) of all the values of the nodes in the tree .<br>	<b>OPTIMIZED</b></br>Use a single pointer and a stack. Iterate while stack or pointer are not empty. Push cur.left to the stack, until cur.left is None. Pop from the stack, decrement k, and check if k == 0 to return the node's value. Otherwise, set cur to cur.right and continue</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Construct Binary Tree from Preorder and Inorder Traversal</b></br>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree . 	<b>OPTIMIZED</b></br>If either traversal is empty, return None. The 1st element in preorder is the root. Use inorder to find the root's index (mid). In inorder, elements left of mid are the left subtree, and elements right of mid are the right subtree. Recursively build subtrees</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Binary Tree Maximum Path Sum</b></br>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once . Note that the path does not need to pass through the root.The path sum of a path is the sum of the node's values in the path.Given the root of a binary tree, return the maximum path sum of any non-empty path 	<b>OPTIMIZED</b></br>Perform a postorder traversal to calculate the path sum, of the max height of the left(l) and right(r) subtrees, treating negative values as 0. For each node, update the max_path_sum if (n.val + l + r) exceeds the current maximum. Return the path sum contribution of node as (n.val + max(l, r)). Finally, return max_path_sum</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Serialize and Deserialize Binary Tree</b></br>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. 	<b>OPTIMIZED</b></br>Use the same traversal for encoding and decoding. For encoding, if a node is None, add 'N' to res; otherwise, add str(node.val). For decoding, split the string by ','; if 'N', return None, otherwise return TreeNode(val) while incrementing self.i. Finally, return the root</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Trees
<b>Kth Largest Element in a Stream</b></br>You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.Implement the KthLargest class:<ul><li>KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums.</li><li>int add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.</li></ul> 	<b>OPTIMIZED</b></br>Heapify nums to a min_heap and reduce the size to k. In add(), push element to heap, if len(min_heap) > k: pop and return min_heap[0]</br><b>COMPLEXITY</b></br>Time: O(m∗logk); Space: O(k), where m is the number of calls to add</br><b>BRUTE FORCE</b></br>Use an array. For each element added, sort and return arr[len-k]</br><b>COMPLEXITY</b></br>Time: O(m∗n*logn); Space: O(1) or O(n), depending on sorting algorithm	Heap/Priority-Queue
<b>Last Stone Weight</b></br>You are given an array of integers stones where stones[i] is the weight of the ith stone.We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:<ul><li>If x == y, both stones are destroyed, and</li><li>If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.</li></ul>At the end of the game, there is at most one stone left.Return the weight of the last remaining stone . If there are no stones left, return 0. 	<b>OPTIMIZED</b></br>Use a max-heap to repeatedly extract the two largest stones, smash them, and push the remaining stone back into the heap if any. Return the last stone in the heap or 0 if the heap is empty.</br><b>COMPLEXITY</b></br>Time: O(n∗logn); Space: O(n)</br><b>BRUTE FORCE</b></br></br>Iterate through stones, sort, pop 2 stones, and append if necessary. Finally return a stone if exists or 0<b>COMPLEXITY</b></br>Time: O(n^2*logn); Space: O(1) or O(n), depending on sorting algorithm	Heap/Priority-Queue
<b>K Closest Points to Origin</b></br>Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).You may return the answer in any order . The answer is guaranteed to be unique (except for the order that it is in). 	<b>OPTIMIZED</b></br>Use a min-heap to store vertices sorted by Euclidean distance. Repeatedly pop elements from the heap until the k-th smallest is reached, and then return it.</br><b>COMPLEXITY</b></br>Time: O(n∗log k); Space: O(k)</br><b>BRUTE FORCE</b></br>Sort based on euclidean distance(custom sort function). Return subarray upto index k</br><b>COMPLEXITY</b></br>Time: O(n*logn); Space: O(1) or O(n), depending on sorting algorithm	Heap/Priority-Queue
<b>Kth Largest Element in an Array</b></br>Given an integer array nums and an integer k, return the kth largest element in the array .Note that it is the kth largest element in the sorted order, not the kth distinct element.Can you solve it without sorting? 	<b>OPTIMIZED</b></br>Using heapq.nlargest and return[-1]</br><b>COMPLEXITY</b></br>Time: O(n*logk); Space: O(k)</br><b>BRUTE FORCE</b></br>Sort and return the subarray till (len - k)</br><b>COMPLEXITY</b></br>Time: O(n*logn); Space: O(1) or O(n), depending on sorting algorithm	Heap/Priority-Queue
<b>Task Scheduler</b></br>You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.Return the minimum number of CPU intervals required to complete all tasks. 	<b>OPTIMIZED</b></br>Maintain 2 queues(free_q & idling_q). Construct free_q as a max_heap based on frequency. Simulate seconds while iterating, until both queues are empty. Each tick, consume a task from the free_q and move the remainder of the task to the idling_q [count, time+n]. If idling time is up, popleft from the idling q and add remaining tasks to the free_q. Finally return ticks</br><b>COMPLEXITY</b></br>Time: O(m); Space: O(1), where m is the number of tasks</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Heap/Priority-Queue
<b>Design Twitter</b></br>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.Implement the Twitter class:<ul><li>Twitter() Initializes your twitter object.</li><li>void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.</li><li>List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent .</li><li>void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.</li><li>void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.</li></ul> 	<b>OPTIMIZED</b></br>Create a singly linked list class Tweet, with id, timestamp and next pointer. In class Twitter, create 2 dictionaries, following{uid: [follow_id]} and tweets{uid: Tweethead}, Initialize an incrementing timestamp to 0, to store last_modified to tweets when added. In postTweet, add timestamp as last_modified. For follow() and unfollow() add and discard from following dict. For getNewsFeed(), first create a max_heap based on last_modified for tweets for all following and user itself. To generate feed while heap is not empty and len(feed) < FEED_SIZE, pop from heap append to feed and add the tweet's next back to the heap. Finally return feed</br><b>COMPLEXITY</b></br>Time: O(nlogn) for each getNewsFeed() call and O(1) for remaining methods; Space: O(N∗m+N∗M+n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Heap/Priority-Queue
<b>Find Median from Data Stream</b></br>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.<ul><li>For example, for arr = [2,3,4], the median is 3.</li><li>For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.</li></ul>Implement the MedianFinder class:<ul><li>MedianFinder() initializes the MedianFinder object.</li><li>void addNum(int num) adds the integer num from the data stream to the data structure.</li><li>double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.</li></ul> 	<b>OPTIMIZED</b></br>Use 2 arrays as min & max heaps. For addNum(), Follow a 2 step process. First Insert, if num < max_heap[0]: push into max_heap otherwise push to min_heap. Then rebalance, if len of either heap is greater than the other by 1. For findMedian(), For the odd len case, return the top of the longer heap. For even case, get the top values by peaking, and return (v1+v2)/2</br><b>COMPLEXITY</b></br>Time: O(m∗logn) for addNum(), O(m) for findMedian(); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Heap/Priority-Queue
<b>Subsets</b></br>Given an integer array nums of unique elements, return all possible subsets (the power set) .The solution set must not contain duplicate subsets. Return the solution in any order . 	<b>OPTIMIZED</b></br>Implement a dfs() method that takes an iterator and uses the pick-and-no-pick algorithm to explore subsets. At each step, include the current element & skip it. Add the current subset to the result list when the iterator reaches the end of nums</br><b>COMPLEXITY</b></br>Time: O(n * 2^n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Combination Sum</b></br>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target . You may return the combinations in any order .The same number may be chosen from candidates an unlimited number of times . Two combinations are unique if the frequency of at least one of the chosen numbers is different.The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. 	<b>OPTIMIZED</b></br>Define dfs(i, cur, total). Base cases: if target == total, append cur.copy() to res and return. If idx >= len(nums) or total > target, return. Append nums[i] to cur, add to total, then call dfs(). After, pop() from cur, subtract nums[i] from total, increment i, and call dfs() again. Finally, return res</br><b>COMPLEXITY</b></br>Time: O(2^(t/m)); Space: O(t/m), Where t is the given target and m is the minimum value in nums</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Combination Sum II</b></br>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. 	<b>OPTIMIZED</b></br>Sort the array to handle duplicates efficiently, then use backtracking to explore combinations while maintaining a running total. Append valid combinations when the total matches the target and terminate early if it exceeds the target. Skip duplicate elements during iteration to avoid redundant results</br><b>COMPLEXITY</b></br>Time: O(n ∗ 2^n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Permutations</b></br>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order . 	<b>OPTIMIZED</b></br>Define backtrack(cur), with BC: if len(cur) == len(nums), add it to res and return. Otherwise loop through nums, if n is not in cur add it, and recursively call backtrack with the new cur, then pop the element and continue the iteration. Return res at the end</br><b>COMPLEXITY</b></br>Time: O(n! * n); Space: O(n! * n) for the output list</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Subsets II</b></br>Given an integer array nums that may contain duplicates, return all possible subsets (the power set) .The solution set must not contain duplicate subsets. Return the solution in any order . 	<b>OPTIMIZED</b></br>Sort input array to group duplicates, then use backtracking to generate subsets by either including the current element (pick) or skipping it (no-pick); before making no-pick recursive call, ensure duplicates are skipped by advancing the index to the next unique value, thereby avoiding duplicates</br><b>COMPLEXITY</b></br>Time: O(n * 2^n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Word Search</b></br>Given an m x n grid of characters board and a string word, return true if word exists in the grid .The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. 	<b>OPTIMIZED</b></br>Define dfs(r, c, i). If i == len(word), return True. If r or c are out of bounds, characters don't match, or the cell is already in the path, return False. If the current cell matches word[i], add it to the path, and recursively check neighboring cells recording result. backtrack by removing the cell from the path and return result</br><b>COMPLEXITY</b></br>Time: O(n * 4^n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Palindrome Partitioning</b></br>Given a string s, partition s such that every substring of the partition is a palindrome . Return all possible palindrome partitioning of s.<br>	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Letter Combinations of a Phone Number</b></br>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order .A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 	<b>OPTIMIZED</b></br>Create a map of numbers to a list of letters. Use a param start to backtrack() that increments each recursive call and tracks the idx of digits. BCs- len(path) == len(digits), add to res and return. start >= len(digits), return. Guard the backtrack call by a condition that checks if len(digits) > 0. Return combinations collected.</br><b>COMPLEXITY</b></br>Time: O(n * 4^n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>N-Queens</b></br>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return all distinct solutions to the n-queens puzzle . You may return the answer in any order .Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. 	<b>OPTIMIZED</b></br>Create a fn that validates a (row, col) against already placed queens. Create another fn, that attempts to place queens on the board, if the (r,c) is a valid placement, place a queen, and recurse to attempt to place on the next row. BC: when len of placed queens reaches board size, save a copy of the board. Finally return placed queens.</br><b>COMPLEXITY</b></br>Time: O(n!); Space: O(n^2)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Backtracking
<b>Implement Trie (Prefix Tree)</b></br>A trie (pronounced as try ) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.Implement the Trie class:<ul><li>Trie() Initializes the trie object.</li><li>void insert(String word) Inserts the string word into the trie.</li><li>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.</li><li>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</li></ul> 	<b>OPTIMIZED</b></br>Use a TrieNode with a children HashMap and a boolean end_of_word set to False. For insert, traverse the Trie from the root, creating a new TrieNode for each letter in the word if it doesn't already exist in children, and move to the node. After processing all letters, mark end_of_word as True. For search, traverse from the root, checking if each letter exists in children. If any letter is missing, return False; otherwise, continue to the next node. After processing all letters, return whether end_of_word is True for the final node. For startsWith: Follow the same logic as Search(), but finally return True irrespective if we reached an end_of_word or not</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(t); n is length of word and t is no. of trie nodes</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Tries
<b>Design Add and Search Words Data Structure</b></br>Design a data structure that supports adding new words and finding if a string matches any previously added string.Implement the WordDictionary class:<ul><li>WordDictionary() Initializes the object.</li><li>void addWord(word) Adds word to the data structure, it can be matched later.</li><li>bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.</li></ul> 	<b>OPTIMIZED</b></br>In the AddWord method, the process remains identical to the insert method in a Trie. For search, a recursive approach is used: if the current character is not '.', check if it exists in the current node's children and continue the search(return False if not present). If the character is '.', recursively explore all children nodes, returning True if any branch leads to a match. If no valid path exists, return False</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n + t) where t is stack space</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Tries
<b>Word Search II</b></br>Given an m x n board of characters and a list of strings words, return all words on the board .Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. 	<b>OPTIMIZED</b></br>Insert words into a Trie, then traverse the board recursively, exploring neighbors to match characters with Trie nodes. Terminate on mismatches and backtrack by marking and unmarking visited cells. Trie traversal handles mismatches, so explicit backtracking on the Trie isn’t needed</br><b>COMPLEXITY</b></br>Time: O ( m ∗ n ∗ 4 ∗ 3 t − 1 + s ) Space: O ( s )</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Tries
<b>Number of Islands</b></br>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands .An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 	<b>OPTIMIZED</b></br> Define dfs(r, c) with BC: return if r or c are out of bounds, if grid[r][c] is not 1 , or if (r, c) is in the visited set. If conditions are met, add (r, c) to visited and perform dfs on its four neighbors. Use a nested loop for r and c, and if grid[r][c] is 1 and not in visited, increment the islands and call dfs(r, c)</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br> 	Graphs
<b>Max Area of Island</b></br>You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.The area of an island is the number of cells with a value 1 in the island.Return the maximum area of an island in grid. If there is no island, return 0. 	<b>OPTIMIZED</b></br>Define dfs(r, c) with BC: return 0 if r or c are out of bounds, or if (r, c) is in the visited set. If conditions are met, add (r, c) to visited and return (1 + sum of dfs on each of its four neighbors). Use a nested loop for r and c, and maintain a running max_area updated with the result of each dfs call. Return max_area at the end</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Clone Graph</b></br>Given a reference of a node in a connected undirected graph.Return a deep copy (clone) of the graph.Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.<b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. 	<b>OPTIMIZED</b></br>Create a HashMap to track visited nodes. Define dfs(node) with a BC: if node is already visited, return its corresponding value from the HashMap. Otherwise, create a copy with node.val & map it in the HashMap. Then iterate through node's neighbors, appending the result of dfs(neighbor) to copy's neighbors. Finally, return the copy</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Islands and Treasure</b></br>You are given a m×n m × n 2D grid initialized with these three possible values:<ol><li>-1 - A water cell that can not be traversed.</li><li>0 - A treasure chest.</li><li>INF - A land cell that can be traversed. We use the integer 2^31 - 1 = 2147483647 to represent INF.</li></ol>Fill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest than the value should remain INF.Assume the grid can only be traversed up, down, left, or right. 	<b>OPTIMIZED</b></br>Loop across the grid till we find a treasure. Maintain running minimums for all non (-1 & 0) neighbours. Use a visited set to avoid revisits in each backtrack. and avoid traversing if we find another 0. Return the grid modified in place at the end</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Rotting Oranges</b></br>You are given an m x n grid where each cell can have one of three values:<ul><li>0 representing an empty cell,</li><li>1 representing a fresh orange, or</li><li>2 representing a rotten orange.</li></ul>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.Return the minimum number of minutes that must elapse until no cell has a fresh orange . If this is impossible, return -1. 	<b>OPTIMIZED</b></br>Iterate through cells in the grid to collect 2's in a q and maintain a count of 1's(fresh). Execture BFS on 2's and change neighbours with 1->2, and updating fresh. Gate BFS while, with fresh > 0 for a potential early exit. And finally return minutes if no ones remain otherwise -1</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Pacific Atlantic Water Flow</b></br>There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean . The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans . 	<b>OPTIMIZED</b></br>Define dfs(r, c, pre_height) with BC: return if current cell (r, c) is out of bounds, has (height < pre_height), or already in visited. Use 2 HashSets to track cells reachable from the pac and atl oceans. Loop through cols to add nodes reachable from the first and last row to the Pacific and Atlantic sets. Similarly, loop through rows to add nodes reachable from the first and last column. Finally, loop through the grid(r & c) and add cells that reach both oceans to the result, and return it</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Surrounded Regions</b></br>You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded :<ul><li> Connect : A cell is connected to adjacent cells horizontally or vertically.</li><li> Region : To form a region connect every 'O' cell.</li><li> Surround : The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board.</li></ul>A surrounded region is captured by replacing all 'O's with 'X's in the input matrix board. 	<b>OPTIMIZED</b></br>Run dfs from edges of board marking all reachable O's as T's. Iterate through board, changing all O's to X's followed by all T's to O's</br><b>COMPLEXITY</b></br>Time: O(m * n); Space: O(m * n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Course Schedule</b></br>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.<ul><li>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.</li></ul>Return true if you can finish all courses. Otherwise, return false. 	<b>OPTIMIZED</b></br>Create adjacency list for directed graph. Define dfs(c) with BCs: if course already visited, return False; if course has no dependencies, return True. For each course, Add it to visited, check its dependencies with dfs(). If any dfs() call fails, return False. After processing, remove course from visited, empty adj[c] and return True. If dfs() fails for any course, return False; otherwise, return True</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V + E)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Course Schedule II</b></br>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.<ul><li>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.</li></ul>Return the ordering of courses you should take to finish all courses . If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array . 	<b>OPTIMIZED</b></br>Similar to original problem, Maintain a cycle set, that works similar to the visit set. After we remove from the cycle set, add to visit set & res, for the True base condition, check if course exists in visit set instead of whether pre_reqs are empty. Return [], if dfs failed, otherwise return res</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V + E)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Graph Valid Tree</b></br>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.<br>	<b>OPTIMIZED</b></br>Create an adjacency list for each node using a HashMap (undirected graph). Use a set to track visited nodes. Define dfs(i, prev) with BC: if node already visited, return False. For each node, iterate through its neighbors, skipping previous node. If any check fails, return False, otherwise finally True. Return dfs(0, -1) and (len(visited) == n)</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V + E)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Number of Connected Components in an Undirected Graph</b></br>There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph.The nodes are numbered from 0 to n - 1.Return the total number of connected components in that graph.	<b>OPTIMIZED</b></br>Create adjacency list for each vertex and a visited list for each n ([False] * n), For each vertex, if not visited, run dfs and increase component count. Finally return components.</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V + E)</br><b>BRUTE FORCE</b></br>Use Union-Find with parent and rank arrays. Define findRootParent(v) to get the absolute root parent of a node. Define union(v1, v2) to merge two nodes by their root parents. If they share the same parent, return 0; otherwise, merge them and return 1. Initialize res to the number of nodes, and for each edge, decrement res by the result of union(e1, e2)</br><b>COMPLEXITY</b></br>Time: O(V + E); Space: O(V + E)	Graphs
<b>Redundant Connection</b></br>In this problem, a tree is an undirected graph that is connected and has no cycles.You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.Return an edge that can be removed so that the resulting graph is a tree of n nodes . If there are multiple answers, return the answer that occurs last in the input. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Word Ladder</b></br>A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:<ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.</li><li>sk == endWord</li></ul>Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord , or 0 if no such sequence exists. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Graphs
<b>Min Cost to Connect All Points</b></br>You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Network Delay Time</b></br>You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal . If it is impossible for all the n nodes to receive the signal, return -1. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Cheapest Flights Within K Stops</b></br>There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Reconstruct Itinerary</b></br>You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.All of the tickets belong to a man who departs from JFK , thus, the itinerary must begin with JFK . If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.<ul><li>For example, the itinerary [ JFK , LGA ] has a smaller lexical order than [ JFK , LGB ].</li></ul>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Swim in Rising Water</b></br>You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Alien Dictionary</b></br>There is a foreign language which uses the latin alphabet, but the order among letters is not a , b , c ... z as in English.You receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language.Derive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return any of them.A string a is lexicographically smaller than a string b if either of the following is true:<ul><li>The first letter where they differ is smaller in a than in b.</li><li>There is no index i such that a[i] != b[i] and a.length < b.length.</li></ul> 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Advanced-Graphs
<b>Climbing Stairs</b></br>You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 	<b>OPTIMIZED</b></br>This recurrance relation is similar to fibonacci. For 1&2:return n, <1:return 0. Use a recursive function with HashMap as cache.</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Min Cost Climbing Stairs</b></br>You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.You can either start from the step with index 0, or the step with index 1.Return the minimum cost to reach the top of the floor . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>House Robber</b></br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight <b>without alerting the police</b> . 	<b>OPTIMIZED</b></br>Use a recursive function rRob with BCs- <0:return 0, 0: return nums[0]. Calculate max of take and skip, and return it. Memoize this</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>House Robber II</b></br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police . 	<b>OPTIMIZED</b></br>Define function rob1(). If nums size is 1, return nums[0]. Otherwise, return maximum of rob1(nums[1:]) and rob1(nums[:len(nums)-1])</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Longest Palindromic Substring</b></br>Given a string s, return the longest palindromic substring in s. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br> 	1D-DP
<b>Palindromic Substrings</b></br>Given a string s, return the number of palindromic substrings in it .A string is a palindrome when it reads the same backward as forward.A substring is a contiguous sequence of characters within the string. 	<b>OPTIMIZED</b></br>Initialize count to 0. Loop through the string, checking for odd-length (l, r = i, i) and even-length (l, r = i, i+1) palindromes using expand-from-center algorithm. Increment count for each palindrome found, and return total count at the end</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Decode Ways</b></br>You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:"1" -> 'A'; "2" -> 'B'; "25" -> 'Y'; "26" -> 'Z'. However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes ( 2 and 5 vs 25 ).For example, 11106 can be decoded into:<ul><li> AAJF with the grouping (1, 1, 10, 6)</li><li> KJF with the grouping (11, 10, 6)</li><li>The grouping (1, 11, 06) is invalid because 06 is not a valid code (only 6 is valid).</li></ul>Note: there may be strings that are impossible to decode.<br><br>Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.The test cases are generated so that the answer fits in a 32-bit integer. 	<b>OPTIMIZED</b></br>BCs: If s is '' or starts with '0', return 0. If s length is 1, return 1. Initialize upto_prev and upto_cur to 1. Loop from 1 to len(s). Convert s[i] and (s[i-1] + s[i]) to 0-based integers. If cur > 0, add upto_cur to val. If prev forms a number between 10 and 26, add upto_prev to val. Update upto_prev to upto_cur and upto_cur to val. Finally, return upto_cur</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Coin Change</b></br>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the fewest number of coins that you need to make up that amount . If that amount of money cannot be made up by any combination of the coins, return -1.You may assume that you have an infinite number of each kind of coin. 	<b>OPTIMIZED</b></br>Use tabulation to create a DP array of size amount + 1, initialized to amount + 1. For each amount from 1 to amount, loop through each coin and update dp[a] to the minimum of dp[a] and 1 + dp[a - c]. Return dp[amount] if it's updated, otherwise return -1.</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Maximum Product Subarray</b></br>Given an integer array nums, find a subarray that has the largest product, and return the product .The test cases are generated so that the answer will fit in a 32-bit integer. 	<b>OPTIMIZED</b></br>Initialize cur_max and cur_min to 1 & res to nums[0]. Loop through nums, updating cur_max as the maximum and cur_min as the minimum of (n * cur_max, n * cur_min, n) for each n. Update res as the maximum of res and cur_max. Return res</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Word Break</b></br>Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. 	<b>OPTIMIZED</b></br>Initialize DP array with False and set the last element to True. Loop through the string in reverse, checking each substring against the list of words. If a match is found, update the DP array at the current index to dp[i + len(w)] and break the inner loop. Finally, return the value of dp[0]</br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Longest Increasing Subsequence</b></br>Given an integer array nums, return the length of the longest strictly increasing subsequence 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Partition Equal Subset Sum</b></br>Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise .<br>	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	1D-DP
<b>Unique Paths</b></br>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner .The test cases are generated so that the answer will be less than or equal to 2 * 109. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Longest Common Subsequence</b></br>Given two strings text1 and text2, return the length of their longest common subsequence . If there is no common subsequence , return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.<ul><li>For example, ace is a subsequence of abcde .</li></ul>A common subsequence of two strings is a subsequence that is common to both strings. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Best Time to Buy and Sell Stock with Cooldown</b></br>You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:<ul><li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li></ul> Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Coin Change II</b></br>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the number of combinations that make up that amount . If that amount of money cannot be made up by any combination of the coins, return 0.You may assume that you have an infinite number of each kind of coin.The answer is guaranteed to fit into a signed 32-bit integer. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Target Sum</b></br>You are given an integer array nums and an integer target.You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.<ul><li>For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression +2-1 .</li></ul>Return the number of different expressions that you can build, which evaluates to target. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Interleaving String</b></br>Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:<ul><li>s = s1 + s2 + ... + sn</li><li>t = t1 + t2 + ... + tm</li><li>|n - m| <= 1</li><li>The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...</li></ul> Note: a + b is the concatenation of strings a and b. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Longest Increasing Path in a Matrix</b></br>Given an m x n integers matrix, return the length of the longest increasing path in matrix.From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Distinct Subsequences</b></br>Given two strings s and t, return <i>the number of distinct</i> <b><i>subsequences</i></b><i> of </i>s<i> which equals </i>t.The test cases are generated so that the answer fits on a 32-bit signed integer. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Edit Distance</b></br>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2 .You have the following three operations permitted on a word:<ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul> 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Burst Balloons</b></br>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.Return the maximum coins you can collect by bursting the balloons wisely . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Regular Expression Matching</b></br>Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:<ul><li>'.' Matches any single character.​​​​</li><li>'*' Matches zero or more of the preceding element.</li></ul>The matching should cover the entire input string (not partial). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	2D-DP
<b>Maximum Subarray</b></br>Given an integer array nums, find the subarray with the largest sum, and return its sum. 	<b>OPTIMIZED</b></br>Initialize max to nums[0] and cur to 0. Iterate through nums, if (cur < 0), reset cur to 0, add num to cur and maintain the running max. Return max at the end</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br>Use 2 nested loops and 2 variables cur and max, let first loop be the l pointer and 2nd loop be r. Keep adding to cur and maintain a running max, finally return max</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Greedy
<b>Jump Game</b></br>You are given an integer array nums. You are initially positioned at the array's first index , and each element in the array represents your maximum jump length at that position.Return true if you can reach the last index, or false otherwise . 	<b>OPTIMIZED</b></br>Intialize goalpost to last index. Iterate through nums in reverse, for each i, check if (i + nums[i]) >= goalpost, if so move goalpost to i. Finally return goalpost == 0</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Jump Game II</b></br>You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:<ul><li>0 <= j <= nums[i] and</li><li>i + j < n</li></ul>Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Gas Station</b></br>There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Hand of Straights</b></br>Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Merge Triplets to Form Target Triplet</b></br>A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet . You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.To obtain target, you may apply the following operation on triplets any number of times (possibly zero ):<ul><li>Choose two indices ( 0-indexed ) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].<ul><li>For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].</li></ul></li></ul>Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets , or false otherwise . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Partition Labels</b></br>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.Return a list of integers representing the size of these parts . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Valid Parenthesis String</b></br>Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid .The following rules define a valid string:<ul><li>Any left parenthesis '(' must have a corresponding right parenthesis ')'.</li><li>Any right parenthesis ')' must have a corresponding left parenthesis '('.</li><li>Left parenthesis '(' must go before the corresponding right parenthesis ')'.</li><li>'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string .</li></ul> 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Greedy
<b>Insert Interval</b></br>You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).Return intervals after the insertion . Note that you don't need to modify intervals in-place. You can make a new array and return it. 	<b>OPTIMIZED</b></br>Sort intervals. Add intervals to res, that end before newInterval starts(intervals[i][1] < newInterval[0]). Then, merge newInterval to reflect all overlapping intervals(intervals[i][0] <= newInterval[1]). Then, add any remaining intervals. Return res</br><b>COMPLEXITY</b></br>Time: O(n); Space: O(1)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Intervals
<b>Merge Intervals</b></br>Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input .<br>	<b>OPTIMIZED</b></br>Sort intervals based on starts. Create result array with 1st element of interval. Iterate through intervals from index 1, if the end of last interval in res is >= start of current interval, then update the end of the interval in res to max(end of current, end of res[-1]), otherwise add current to res. Return res finally</br><b>COMPLEXITY</b></br>Time: O(nlogn); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Intervals
<b>Non-overlapping Intervals</b></br>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping . Note that intervals which only touch at a point are non-overlapping . For example, [1, 2] and [2, 3] are non-overlapping. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Intervals
<b>Meeting Rooms</b></br>Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), determine if a person could add all meetings to their schedule without any conflicts.<br>	<b>OPTIMIZED</b></br>Sort intervals by start time. Iterate from [1..len(intervals)], if (interval[i-1].end > interval[i].start) return False. Otherwise True</br><b>COMPLEXITY</b></br>Time: O(nlogn); Space: O(n)</br><b>BRUTE FORCE</b></br>Dont sort. For each interval compare with all other intervals, if there is an overlap return False else True</br><b>COMPLEXITY</b></br>Time: O(n^2); Space: O(1)	Intervals
<b>Meeting Rooms II</b></br>Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), find the minimum number of days required to schedule all meetings without any conflicts.<br>	<b>OPTIMIZED</b></br>Create 2 arrays of sorted start and end times, Iterate while s < len(intervals). if start[s] < end[e], increment count and s. else increment e and decrement count. Update rooms at the end of each iteration. Finally return rooms</br><b>COMPLEXITY</b></br>Time: O(nlogn); Space: O(n)</br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br><b>OPTIMIZED</b></br>	Intervals
<b>Minimum Interval to Include Each Query</b></br>You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive) . The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.Return an array containing the answers to the queries . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Intervals
<b>Rotate Image</b></br>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place , which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br><b>OPTIMIZED</b></br>	Math&Geometry
<b>Spiral Matrix</b></br>Given an m x n matrix, return all elements of the matrix in spiral order . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Set Matrix Zeroes</b></br>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Happy Number</b></br>Write an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:<ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li><li>Those numbers for which this process ends in 1 are happy.</li></ul>Return true if n is a happy number, and false if not . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Plus One</b></br>You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.Increment the large integer by one and return the resulting array of digits . 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Pow(x, n)</b></br>Implement pow(x, n), which calculates x raised to the power n (i.e., xn). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Multiply Strings</b></br>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Detect Squares</b></br>You are given a stream of points on the X-Y plane. Design an algorithm that:<ul><li> Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.</li><li>Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area .</li></ul>An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.Implement the DetectSquares class:<ul><li>DetectSquares() Initializes the object with an empty data structure.</li><li>void add(int[] point) Adds a new point point = [x, y] to the data structure.</li><li>int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.</li></ul> 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Math&Geometry
<b>Single Number</b></br>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Number of 1 Bits</b></br>Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Counting Bits</b></br>Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n) , ans[i] is the number of 1 's in the binary representation of i.<br>	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Reverse Bits</b></br>Reverse bits of a given 32 bits unsigned integer. Note: <ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.</li></ul> 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Missing Number</b></br>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Sum of Two Integers</b></br>Given two integers a and b, return the sum of the two integers without using the operators + and -. 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
<b>Reverse Integer</b></br>Given a signed 32-bit integer x, return x with its digits reversed . If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). 	<b>OPTIMIZED</b></br></br><b>COMPLEXITY</b></br></br><b>BRUTE FORCE</b></br></br><b>COMPLEXITY</b></br>	Bit-Manipulation
